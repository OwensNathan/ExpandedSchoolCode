@implements IDisposable
@inject CombinationOfSchoolCode.Shared.GameEngine Engine
@inject IJSRuntime JSRuntime

<h3>Zookkooz (Kroz Adventure)</h3>

@if (!gameStarted)
{
    <div>
        <p>Welcome to Zookkooz! Navigate through the dungeon, collect all gems (ðŸ’Ž), avoid enemies (ðŸ‘¾), and reach the exit (ðŸšª)!</p>
        <p><strong>Current Level:</strong> @currentLevel / @totalLevels</p>
        <p><strong>Controls:</strong> Use W/A/S/D or Arrow keys to move</p>
        <p><strong>Legend:</strong></p>
        <ul>
            <li>ðŸ§‘ - You (Player)</li>
            <li>ðŸ’Ž - Gems (collect them all!)</li>
            <li>ðŸ‘¾ - Enemy (avoid or you die!)</li>
            <li>ðŸšª - Exit (reach it to win)</li>
            <li>ðŸ§± - Walls (can't pass through)</li>
            <li>â¬œ - Empty space (walkable path)</li>
        </ul>
        <button @onclick="StartGame">Start Level @currentLevel</button>
        @if (currentLevel > 1)
        {
            <button @onclick="ResetToLevel1">Reset to Level 1</button>
        }
        <button @onclick="OnExit.InvokeAsync">Back to Menu</button>
    </div>
}
else if (gameOver)
{
    <div>
        <h4>@gameMessage</h4>
        <p>Gems Collected: @gemsCollected / @totalGems</p>
        <button @onclick="StartGame">Play Again</button>
        <button @onclick="OnExit.InvokeAsync">Back to Menu</button>
    </div>
}
else
{
    <div>
        <p>Level @currentLevel / @totalLevels | Gems: @gemsCollected / @totalGems | Moves: @moveCount</p>
        <div style="font-family: monospace; line-height: 1.2; font-size: 24px;">
            @for (int row = 0; row < gridHeight; row++)
            {
                <div>
                    @for (int col = 0; col < gridWidth; col++)
                    {
                        @GetCellDisplay(row, col)
                    }
                </div>
            }
        </div>
        <p style="margin-top: 10px;">@statusMessage</p>
        <button @onclick="OnExit.InvokeAsync">Back to Menu</button>
    </div>
}

@code {
    [Parameter] public EventCallback OnExit { get; set; }

    private bool gameStarted = false;
    private bool gameOver = false;
    private string gameMessage = "";
    private string statusMessage = "";
    private int moveCount = 0;

    private const int gridWidth = 15;
    private const int gridHeight = 10;
    private char[,] grid = new char[gridHeight, gridWidth];
    
    private int playerRow = 1;
    private int playerCol = 1;
    private int exitRow = 8;
    private int exitCol = 13;
    
    private int gemsCollected = 0;
    private int totalGems = 0;
    
    private int currentLevel = 1;
    private const int totalLevels = 4;
    
    private List<(int row, int col)> enemies = new List<(int, int)>();
    private DotNetObjectReference<Zookkooz>? dotNetReference;
    private string listenerId = Guid.NewGuid().ToString();
    
    private const int MaxKeyLength = 20;

    public void Dispose()
    {
        if (dotNetReference != null)
        {
            JSRuntime.InvokeVoidAsync("cleanupKeyboardListener", listenerId);
            dotNetReference?.Dispose();
        }
    }

    [JSInvokable]
    public void HandleKeyPress(string key)
    {
        // Validate input is not null or empty
        if (string.IsNullOrEmpty(key) || !gameStarted || gameOver) return;
        
        // Limit key string length to prevent potential abuse
        if (key.Length > MaxKeyLength) return;

        int newRow = playerRow;
        int newCol = playerCol;

        switch (key.ToUpper())
        {
            case "W":
            case "ARROWUP":
                newRow--;
                break;
            case "S":
            case "ARROWDOWN":
                newRow++;
                break;
            case "A":
            case "ARROWLEFT":
                newCol--;
                break;
            case "D":
            case "ARROWRIGHT":
                newCol++;
                break;
            default:
                return;
        }

        TryMove(newRow, newCol);
    }

    private async Task StartGame()
    {
        gameStarted = true;
        gameOver = false;
        gameMessage = "";
        statusMessage = $"Level {currentLevel}: Collect all gems to unlock the exit!";
        moveCount = 0;
        gemsCollected = 0;
        
        InitializeGrid(currentLevel);
        StateHasChanged();
        
        // Setup keyboard listener after UI is rendered
        await Task.Delay(10);
        dotNetReference = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("setupKeyboardListener", dotNetReference, listenerId);
    }

    private void ResetToLevel1()
    {
        currentLevel = 1;
        StateHasChanged();
    }

    private void InitializeGrid(int level)
    {
        // Clear grid
        for (int r = 0; r < gridHeight; r++)
        {
            for (int c = 0; c < gridWidth; c++)
            {
                grid[r, c] = ' ';
            }
        }

        // Add borders
        for (int r = 0; r < gridHeight; r++)
        {
            grid[r, 0] = '#';
            grid[r, gridWidth - 1] = '#';
        }
        for (int c = 0; c < gridWidth; c++)
        {
            grid[0, c] = '#';
            grid[gridHeight - 1, c] = '#';
        }

        // Place player at start
        playerRow = 1;
        playerCol = 1;

        // Place exit
        exitRow = gridHeight - 2;
        exitCol = gridWidth - 2;
        grid[exitRow, exitCol] = 'E';

        // Clear enemies list
        enemies.Clear();
        totalGems = 0;

        // Level-specific layouts
        switch (level)
        {
            case 1:
                InitializeLevel1();
                break;
            case 2:
                InitializeLevel2();
                break;
            case 3:
                InitializeLevel3();
                break;
            case 4:
                InitializeLevel4();
                break;
        }
    }

    private void InitializeLevel1()
    {
        // Level 1: Simple introduction level
        // Add some internal walls
        for (int r = 2; r < 6; r++)
        {
            grid[r, 5] = '#';
        }
        for (int c = 7; c < 12; c++)
        {
            grid[4, c] = '#';
        }
        grid[7, 7] = '#';
        grid[7, 8] = '#';
        grid[6, 10] = '#';
        grid[5, 10] = '#';

        // Place gems
        int[] gemPositions = { 3, 3, 3, 7, 3, 11, 6, 3, 6, 7, 8, 5, 8, 10 };
        for (int i = 0; i < gemPositions.Length; i += 2)
        {
            if (grid[gemPositions[i], gemPositions[i + 1]] == ' ')
            {
                grid[gemPositions[i], gemPositions[i + 1]] = 'G';
                totalGems++;
            }
        }

        // Place enemies (3 enemies)
        enemies.Add((2, 8));
        enemies.Add((5, 12));
        enemies.Add((7, 4));
        foreach (var enemy in enemies)
        {
            if (grid[enemy.row, enemy.col] == ' ')
            {
                grid[enemy.row, enemy.col] = 'M';
            }
        }
    }

    private void InitializeLevel2()
    {
        // Level 2: Maze with more enemies
        // Create a more complex maze
        for (int r = 2; r < 8; r++)
        {
            grid[r, 3] = '#';
        }
        for (int c = 3; c < 8; c++)
        {
            grid[2, c] = '#';
        }
        grid[2, 3] = ' '; // Opening
        for (int r = 4; r < 8; r++)
        {
            grid[r, 7] = '#';
        }
        for (int c = 7; c < 12; c++)
        {
            grid[6, c] = '#';
        }
        grid[6, 9] = ' '; // Opening
        grid[4, 11] = '#';
        grid[5, 11] = '#';

        // Place gems (more gems)
        int[] gemPositions = { 1, 5, 2, 10, 4, 2, 4, 5, 5, 9, 6, 12, 7, 5, 8, 8 };
        for (int i = 0; i < gemPositions.Length; i += 2)
        {
            if (grid[gemPositions[i], gemPositions[i + 1]] == ' ')
            {
                grid[gemPositions[i], gemPositions[i + 1]] = 'G';
                totalGems++;
            }
        }

        // Place more enemies (4 enemies)
        enemies.Add((3, 5));
        enemies.Add((5, 2));
        enemies.Add((5, 10));
        enemies.Add((7, 10));
        foreach (var enemy in enemies)
        {
            if (grid[enemy.row, enemy.col] == ' ')
            {
                grid[enemy.row, enemy.col] = 'M';
            }
        }
    }

    private void InitializeLevel3()
    {
        // Level 3: Spiral dungeon
        // Create spiral walls
        for (int c = 2; c < 13; c++)
        {
            grid[2, c] = '#';
        }
        for (int r = 2; r < 8; r++)
        {
            grid[r, 12] = '#';
        }
        for (int c = 3; c < 12; c++)
        {
            grid[7, c] = '#';
        }
        for (int r = 3; r < 7; r++)
        {
            grid[r, 3] = '#';
        }
        for (int c = 4; c < 11; c++)
        {
            grid[3, c] = '#';
        }
        for (int r = 4; r < 6; r++)
        {
            grid[r, 10] = '#';
        }
        grid[5, 5] = '#';
        grid[5, 6] = '#';
        grid[5, 7] = '#';
        grid[5, 8] = '#';

        // Place gems in the spiral
        int[] gemPositions = { 1, 7, 2, 1, 3, 11, 4, 5, 4, 9, 6, 6, 7, 11, 8, 6 };
        for (int i = 0; i < gemPositions.Length; i += 2)
        {
            if (grid[gemPositions[i], gemPositions[i + 1]] == ' ')
            {
                grid[gemPositions[i], gemPositions[i + 1]] = 'G';
                totalGems++;
            }
        }

        // Place enemies (5 enemies - harder!)
        enemies.Add((1, 9));
        enemies.Add((4, 4));
        enemies.Add((4, 11));
        enemies.Add((6, 8));
        enemies.Add((8, 9));
        foreach (var enemy in enemies)
        {
            if (grid[enemy.row, enemy.col] == ' ')
            {
                grid[enemy.row, enemy.col] = 'M';
            }
        }
    }

    private void InitializeLevel4()
    {
        // Level 4: The gauntlet - most challenging!
        // Create narrow corridors with many obstacles
        for (int r = 1; r < 9; r++)
        {
            grid[r, 4] = '#';
            grid[r, 8] = '#';
        }
        grid[3, 4] = ' '; // Opening
        grid[6, 8] = ' '; // Opening
        
        for (int c = 1; c < 14; c++)
        {
            if (c != 4 && c != 8)
            {
                grid[5, c] = '#';
            }
        }
        grid[5, 6] = ' '; // Opening
        grid[5, 10] = ' '; // Opening
        
        grid[2, 6] = '#';
        grid[2, 10] = '#';
        grid[7, 2] = '#';
        grid[7, 6] = '#';
        grid[7, 10] = '#';

        // Place gems strategically
        int[] gemPositions = { 1, 2, 2, 6, 3, 10, 4, 2, 4, 12, 6, 6, 6, 10, 8, 2, 8, 7, 8, 12 };
        for (int i = 0; i < gemPositions.Length; i += 2)
        {
            if (grid[gemPositions[i], gemPositions[i + 1]] == ' ')
            {
                grid[gemPositions[i], gemPositions[i + 1]] = 'G';
                totalGems++;
            }
        }

        // Place many enemies (6 enemies - hardest level!)
        enemies.Add((2, 2));
        enemies.Add((3, 6));
        enemies.Add((4, 10));
        enemies.Add((6, 2));
        enemies.Add((6, 12));
        enemies.Add((8, 5));
        foreach (var enemy in enemies)
        {
            if (grid[enemy.row, enemy.col] == ' ')
            {
                grid[enemy.row, enemy.col] = 'M';
            }
        }
    }

    private void TryMove(int newRow, int newCol)
    {
        // Check bounds
        if (newRow < 0 || newRow >= gridHeight || newCol < 0 || newCol >= gridWidth)
            return;

        char targetCell = grid[newRow, newCol];

        // Check wall
        if (targetCell == '#')
        {
            statusMessage = "Can't walk through walls!";
            StateHasChanged();
            return;
        }

        // Check enemy
        if (targetCell == 'M')
        {
            gameOver = true;
            gameMessage = "ðŸ’€ You were caught by an enemy! Game Over!";
            Engine.AddDeath();
            StateHasChanged();
            return;
        }

        // Check gem
        if (targetCell == 'G')
        {
            gemsCollected++;
            statusMessage = $"Collected a gem! ({gemsCollected}/{totalGems})";
            if (gemsCollected == totalGems)
            {
                statusMessage = "All gems collected! The exit is now open!";
            }
        }

        // Check exit
        if (targetCell == 'E')
        {
            if (gemsCollected >= totalGems)
            {
                int totalMoves = moveCount + 1;
                if (currentLevel < totalLevels)
                {
                    // Progress to next level
                    currentLevel++;
                    gameOver = true;
                    gameMessage = $"ðŸŽ‰ Level {currentLevel - 1} Complete! {totalMoves} moves. Ready for Level {currentLevel}?";
                    StateHasChanged();
                    return;
                }
                else
                {
                    // Won the entire game!
                    gameOver = true;
                    gameMessage = $"ðŸ† GAME COMPLETE! You conquered all {totalLevels} levels in {totalMoves} moves! You're a Zookkooz master!";
                    Engine.AddWin();
                    currentLevel = 1; // Reset for next play
                    StateHasChanged();
                    return;
                }
            }
            else
            {
                statusMessage = $"The exit is locked! Collect all gems first. ({gemsCollected}/{totalGems})";
                StateHasChanged();
                return;
            }
        }

        // Move player
        grid[playerRow, playerCol] = ' ';
        playerRow = newRow;
        playerCol = newCol;
        moveCount++;

        StateHasChanged();
    }

    private string GetCellDisplay(int row, int col)
    {
        if (row == playerRow && col == playerCol)
            return "ðŸ§‘";
        
        char cell = grid[row, col];
        return cell switch
        {
            '#' => "ðŸ§±",
            'G' => "ðŸ’Ž",
            'M' => "ðŸ‘¾",
            'E' => "ðŸšª",
            _ => "â¬œ"
        };
    }
}

<script>
    window.zookkozListeners = window.zookkozListeners || {};
    
    window.setupKeyboardListener = (dotnetHelper, listenerId) => {
        const listener = (e) => {
            if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                dotnetHelper.invokeMethodAsync('HandleKeyPress', e.key);
            }
        };
        window.zookkozListeners[listenerId] = listener;
        document.addEventListener('keydown', listener);
    };
    
    window.cleanupKeyboardListener = (listenerId) => {
        const listener = window.zookkozListeners[listenerId];
        if (listener) {
            document.removeEventListener('keydown', listener);
            delete window.zookkozListeners[listenerId];
        }
    };
</script>